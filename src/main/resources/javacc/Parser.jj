options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(Parser)
    import ast.*;
    import java.util.*;
    public class Parser {
        private static Long counter;
        private static Map<String, Long> map;

        public static void main(String[] args){
          counter = 0L;
          map = new HashMap<>();
        }
    }
PARSER_END(Parser)

<DEFAULT> TOKEN : {
    < #DIGIT : ["0"-"9"] >
  | < #LETTER : ["A"-"Z","a"-"z"] >
  | < LPAREN : "(" >
  | < RPAREN : ")" >
  | < COMMA : "," >
  | < DOT : "." >
  | < QUESTION : "?" >
  | < IMPLIED_BY : ":-" >
  | < VAR_IDENTIFIER : ["a"-"z"] (<LETTER> | <DIGIT> | "_")* >
  | < PRED_IDENTIFIER : ["A"-"Z"] (<LETTER> | <DIGIT> | "_")* >
  | < INTEGER_LITERAL : (<DIGIT>)+ >
}

//
SKIP : {
    < "//"  (~["\r", "\n"])* >
  | < (" " | "\n" | "\r" | "\r\n" | "\t" | "\f" ) >
  | "/*" : ML_CMNT_ST
}


<ML_CMNT_ST> SKIP : {
    "*/" : DEFAULT
}

<ML_CMNT_ST > MORE : {
    < ~[] >
}

Program parse(): {
    List<Atom> facts = new ArrayList<>();
    List<Rule> rules = new ArrayList<>();
    Atom q = null;
} {
    Constraints(facts, rules) (<QUESTION> q=Atom() <QUESTION>)? <EOF> {return new Program(facts, rules, q);}
}

void Constraints(List<Atom> facts, List<Rule> rules) : {
    Atom h;
    List<Atom> b = null;
} {
    h = Atom() (b=Body())? {if(b == null) {facts.add(h);} else {rules.add(new Rule(h, b));}} <DOT> (Constraints(facts, rules))?
}

List<Atom> Body(): {
    List<Atom> bodyList = new ArrayList<>();
    Atom p;
} {
    // Possibly empty body which can have a trailing comma. TODO.
    <IMPLIED_BY> p=Atom() {bodyList.add(p);}  (<COMMA> p=Atom() { bodyList.add(p); })*  { return bodyList; }
}

Atom Atom() : {
    Term id;
    List<Term> argList = new ArrayList<>();
} {
    id=PredIdentifier() <LPAREN> argList=ArgList(argList) <RPAREN> { return new Atom(id, argList); }
}

List<Term> ArgList(List<Term> argList) : {
    Term arg;
} {
    arg=Term() { argList.add(arg); } ( <COMMA> arg=Term() { argList.add(arg); } )*
    { return argList; }
}

Term IntValue() : {
    Token t;
} {
    t=<INTEGER_LITERAL> { return new Term(Long.valueOf(t.image), false); }
}

Term Term() : {
    Term t;
} {
    t = IntValue() { return t; }
|   t = VarIdentifier() { return t; }
}

Term PredIdentifier() : {
    Token t;
} {
    t=<PRED_IDENTIFIER> {
            Long value;
            if (map.containsKey(t.image)) {
                value = map.get(t.image);
            } else {
                value = counter++;
                map.put(t.image, value);
            }
            return new Term(value, true);
        }
}

Term VarIdentifier() : {
    Token t;
} {
    t=<VAR_IDENTIFIER> {
            Long value;
            if (map.containsKey(t.image)) {
                value = map.get(t.image);
            } else {
                value = counter++;
                map.put(t.image, value);
            }
            return new Term(value, true);
        }
}